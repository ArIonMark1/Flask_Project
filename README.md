Задание из двух частей - попроще и посложнее.
(обе части можно объединить)

++++++++++++++++++++++++++++ I ++++++++++++++++++++++++++++++++

Стэк:

- Python 3.7+
- Flask/FastAPI
- PostgreSQL
- SQLAlchemy/Asyncpg
- asyncio

I. Python приложение редактирования пользователей:
1) Минимум две страницы: логин и, собственно, список.( готово )
2) Возможность добавлять/удалять/редактировать пользователей и их права: полные (редактирование/добавление/удаление) и только просмотр. (создал страничку регистрации/редактирования, добавления, кнопки удаления)
3) Пользоваться можно только залогинившись и должно действовать ограничение прав. (готово)
---
4) HTML с запросами через Ajax REST c JSON (простейшее JavaScript приложение - нативно или максимум jQuery) на фронтенде. Да, это не backend, но хороший разработчик будет кристально ясно понимать, что и как происходит на фронте. Можно сделать и просто на формах, Ajax лишь бонус.
---
5) Обязательно показать использование как ORM так и raw SQL.
---
***
---
6) Seed базы - первый пользователь с полными правами.
---
7) Описание запуска проекта в виде: README.md
8) Зависимости проекта в виде: requirements.txt
9) По возможности комментарии к коду (бонус).
10) Проверьте ваш проект на работоспособность - это очевидно.

++++++++++++++++++++++++++++ II ++++++++++++++++++++++++++++++++

Python, асинхронные запросы.
Можно использовать любой доступный метод для достижения “асинхронности” (concurrent computing), включая парадигмы как Reactive и т.п.
1) Есть три удаленных источника данных (в качестве источников для тестового задания
то могут быть два статических JSON файла на том же сервере с массивом простых данных - ID и
некое текстовое поле, содержащее в теле ID).

Пример:
[
    {“id”:1,”name”:”Test 1”},
    {“id”:2,”name”:”Test 2”}
]

Источники доступны по HTTP.
В данных для каждого элемента должен быть ID.

ID распределены следующим образом:
- 1-й источник: ID 1-10,31-40;
- 2-й источник: ID 11-20,41-50;
- 3-й источник: ID 21-30,51-60;

2) Есть одна общая точка доступа до этих данных (приложение Flask), которая выдаёт коррелированный результат.
Точка доступна по HTTP.
3) Эта точка должна делать запросы ко всем источникам “асинхронно” и ждать результата со всех.
4) По получению результата от всех, выдать отсортированный по ID результат (данные со всех источников).
5) Ошибка от любого из источников игнорируется и интерпретируется, как отсутствие данных.
6) Ошибкой также считается таймаут (2 секунды).
