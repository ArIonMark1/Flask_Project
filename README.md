Задание из двух частей - попроще и посложнее.
(обе части можно объединить)

++++++++++++++++++++++++++++ I ++++++++++++++++++++++++++++++++

Стэк:

- Python 3.7+
- Flask/FastAPI
- PostgreSQL
- SQLAlchemy/Asyncpg
- asyncio

I. Python приложение редактирования пользователей:

Создал Flack приложение со страницами логина, регистрации нового пользователя, страницей редактирования пользователя, удаления и подтверждения удаляния пользователя, так же немного оформил страницу ошибки 404.
Рабочая страница пользователя включает список всех пользователей зарегистрированых на сайте, но редактировать их данные может только админ, обычный пользователь может редактировать только свою информацию и только просматривать список других пользователей.
Так же все права имеет только админ и возможность редактировать права допуска других пользователей т.е. присваивать права админа.
Смотреть данные можно только залогинившись, включен login_required.

Для работы с сайтом автоматически первым пользователем создается админ, так же автоматически создается список пользователей с рандомными значениями
на сайте. В  разработке приложения использовал базу данных PostgreSQL и ORM SQLAlchemy.
Есть так же пример выборки из базы данных в файле control_data.py, создал курсор и использовал чистый SQL код.
***
    Запуск проекта происходит с файла run.py, базовые настройки приложения размещены в файле app.py так же и подключение к базе данных.
***
    Для начала работы необходим фйл .env с параметрами базы данных и секретным ключом.
В папке seeds размещены настройки создания фейковых данных, которые сохраняются в .json файл
и после загружаются в базу. 
Шаблоны страниц расположены в папке templates, для их стилизации использовал Bootstrap.
Все нужные библиотеки хранятся в файле requirements.txt

++++++++++++++++++++++++++++ II ++++++++++++++++++++++++++++++++

Python, асинхронные запросы.
Можно использовать любой доступный метод для достижения “асинхронности” (concurrent computing), включая парадигмы как Reactive и т.п.
1) Есть три удаленных источника данных (в качестве источников для тестового задания
то могут быть два статических JSON файла на том же сервере с массивом простых данных - ID и
некое текстовое поле, содержащее в теле ID).

Пример:
[
    {“id”:1,”name”:”Test 1”},
    {“id”:2,”name”:”Test 2”}
]

Источники доступны по HTTP.
В данных для каждого элемента должен быть ID.

ID распределены следующим образом:
- 1-й источник: ID 1-10,31-40;
- 2-й источник: ID 11-20,41-50;
- 3-й источник: ID 21-30,51-60;

2) Есть одна общая точка доступа до этих данных (приложение Flask), которая выдаёт коррелированный результат.
Точка доступна по HTTP.
3) Эта точка должна делать запросы ко всем источникам “асинхронно” и ждать результата со всех.
4) По получению результата от всех, выдать отсортированный по ID результат (данные со всех источников).
5) Ошибка от любого из источников игнорируется и интерпретируется, как отсутствие данных.
6) Ошибкой также считается таймаут (2 секунды).
